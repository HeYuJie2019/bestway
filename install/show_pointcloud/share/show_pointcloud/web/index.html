<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FAST-LIO å®æ—¶ç‚¹äº‘æ˜¾ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
            touch-action: none;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
        }
        
        #info h2 {
            margin-bottom: 10px;
            font-size: 18px;
            color: #4CAF50;
        }
        
        #info .status {
            margin: 5px 0;
        }
        
        .connected {
            color: #4CAF50;
        }
        
        .disconnected {
            color: #f44336;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:active {
            background: #3d8b40;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 600px) {
            #info {
                font-size: 12px;
                padding: 10px;
                max-width: 250px;
            }
            
            #controls {
                bottom: 10px;
                padding: 10px;
            }
            
            button {
                padding: 8px 15px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>è¿æ¥æœåŠ¡å™¨ä¸­...</div>
    </div>
    
    <div id="info">
        <h2>ğŸ“¡ FAST-LIO ç‚¹äº‘æ˜¾ç¤º</h2>
        <div class="status">
            è¿æ¥çŠ¶æ€: <span id="status" class="disconnected">æœªè¿æ¥</span>
        </div>
        <div class="status">
            ç‚¹äº‘æ•°é‡: <span id="pointCount">0</span>
        </div>
        <div class="status">
            æ˜¾ç¤ºæ¨¡å¼: <span id="displayMode">-</span>
        </div>
        <div class="status">
            FPS: <span id="fps">0</span>
        </div>
        <div class="status">
            ä½ç½®: <span id="position">-</span>
        </div>
    </div>
    
    <div id="controls">
        <button id="resetView">é‡ç½®è§†è§’</button>
        <button id="toggleColor">åˆ‡æ¢é¢œè‰²</button>
        <button id="clearMap">æ¸…é™¤åœ°å›¾</button>
    </div>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/"
        }
    }
    </script>
    
    <!-- å…ˆæ‰§è¡ŒWebSocketè¿æ¥ä»£ç ï¼Œä¸ä¾èµ–Three.js -->
    <script>
        // å…¨å±€å˜é‡
        let ws;
        let frameCount = 0;
        let lastTime = Date.now();
        let colorMode = 0; // 0: é«˜åº¦ç€è‰², 1: è·ç¦»ç€è‰², 2: å•è‰²
        let threeJsLoaded = false;
        let pendingPointCloudData = null;
        
        // è·å–æœåŠ¡å™¨åœ°å€ - å¢å¼ºè°ƒè¯•ç‰ˆæœ¬
        let hostname = window.location.hostname;
        
        // å¦‚æœhostnameä¸ºç©ºæˆ–localhostï¼Œå°è¯•å…¶ä»–æ–¹æ³•
        if (!hostname || hostname === 'localhost' || hostname === '127.0.0.1') {
            // ä»URLä¸­æ‰‹åŠ¨æå–
            const url = window.location.href;
            const match = url.match(/https?:\/\/([^:\/]+)/);
            if (match && match[1] !== 'localhost' && match[1] !== '127.0.0.1') {
                hostname = match[1];
            } else {
                hostname = 'localhost';
            }
        }
        
        const wsPort = 9000;
        
        // è¯¦ç»†è°ƒè¯•ä¿¡æ¯
        console.log('=== PointCloud Viewer Starting ===');
        console.log('Current URL:', window.location.href);
        console.log('window.location.hostname:', window.location.hostname);
        console.log('Final hostname:', hostname);
        console.log('WebSocket URL will be: ws://' + hostname + ':' + wsPort);
        console.log('User Agent:', navigator.userAgent);
        console.log('==================================');
        
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // åˆ›å»ºç›¸æœº
            const container = document.getElementById('container');
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            // è°ƒæ•´ç›¸æœºä½ç½® - ä»ä¸Šæ–¹ä¿¯è§†
            camera.position.set(0, 10, 0);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, 1);  // è®¾ç½®Zè½´ä¸ºä¸Šæ–¹å‘
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // æ·»åŠ æ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 500;
            controls.target.set(0, 0, 0);
            
            // æ·»åŠ åæ ‡è½´ (çº¢è‰²=X, ç»¿è‰²=Y, è“è‰²=Z)
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // æ·»åŠ ç½‘æ ¼ (XYå¹³é¢)
            const gridHelper = new THREE.GridHelper(100, 100);
            gridHelper.rotation.x = Math.PI / 2; // æ—‹è½¬90åº¦ä½¿å…¶åœ¨XYå¹³é¢
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // æ·»åŠ æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            
            // åˆ›å»ºç‚¹äº‘å¯¹è±¡
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                opacity: 0.9,
                transparent: true
            });
            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // æŒ‰é’®äº‹ä»¶
            document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('toggleColor').addEventListener('click', toggleColorMode);
            document.getElementById('clearMap').addEventListener('click', clearMap);
            
            // è¿æ¥WebSocket
            connectWebSocket();
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        function connectWebSocket() {
            const wsUrl = `ws://${hostname}:${wsPort}`;
            console.log('ğŸ”Œ Attempting WebSocket connection...');
            console.log('  URL:', wsUrl);
            console.log('  Hostname:', hostname);
            console.log('  Port:', wsPort);
            console.log('  Current time:', new Date().toLocaleTimeString());
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            document.getElementById('status').textContent = 'è¿æ¥ä¸­...';
            document.getElementById('status').className = 'connecting';
            
            try {
                ws = new WebSocket(wsUrl);
                console.log('âœ“ WebSocket object created successfully');
            } catch (e) {
                console.error('âŒ Failed to create WebSocket:', e);
                console.error('  Error type:', typeof e);
                console.error('  Error message:', e.message);
                document.getElementById('status').textContent = 'åˆ›å»ºè¿æ¥å¤±è´¥';
                document.getElementById('status').className = 'disconnected';
                setTimeout(connectWebSocket, 5000);
                return;
            }
            
            ws.onopen = () => {
                console.log('ğŸ‰ WebSocket connected successfully!');
                console.log('  Connection time:', new Date().toLocaleTimeString());
                console.log('  Ready state:', ws.readyState);
                document.getElementById('status').textContent = 'å·²è¿æ¥';
                document.getElementById('status').className = 'connected';
                document.getElementById('loading').style.display = 'none';
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'config') {
                        console.log('Received config:', data);
                        // æ˜¾ç¤ºé…ç½®ä¿¡æ¯
                        const mode = data.enable_full_cloud ? 
                            'å®Œæ•´ç‚¹äº‘' : 
                            `é‡‡æ ·æ˜¾ç¤º (1/${data.downsample_factor})`;
                        document.getElementById('displayMode').textContent = mode;
                    } else if (data.type === 'update') {
                        updatePointCloud(data);
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            };
            
            ws.onerror = (error) => {
                console.error('âŒ WebSocket error occurred:');
                console.error('  Error object:', error);
                console.error('  Error type:', typeof error);
                console.error('  Hostname:', hostname);
                console.error('  Port:', wsPort);
                console.error('  WebSocket URL:', wsUrl);
                console.error('  WebSocket readyState:', ws ? ws.readyState : 'undefined');
                console.error('  Time:', new Date().toLocaleTimeString());
                document.getElementById('status').textContent = 'è¿æ¥é”™è¯¯';
                document.getElementById('status').className = 'disconnected';
            };
            
            ws.onclose = (event) => {
                console.log('ğŸ”Œ WebSocket disconnected:');
                console.log('  Close code:', event.code);
                console.log('  Close reason:', event.reason);
                console.log('  Was clean:', event.wasClean);
                console.log('  Time:', new Date().toLocaleTimeString());
                
                // è§£é‡Šå…³é—­ä»£ç 
                const closeReasons = {
                    1000: 'æ­£å¸¸å…³é—­',
                    1001: 'ç«¯ç‚¹ç¦»å¼€',
                    1002: 'åè®®é”™è¯¯', 
                    1003: 'ä¸æ”¯æŒçš„æ•°æ®ç±»å‹',
                    1006: 'å¼‚å¸¸å…³é—­ï¼ˆæ— å…³é—­å¸§ï¼‰',
                    1011: 'æœåŠ¡å™¨é”™è¯¯',
                    1015: 'TLSæ¡æ‰‹å¤±è´¥'
                };
                const reasonText = closeReasons[event.code] || 'æœªçŸ¥åŸå› ';
                console.log('  Code meaning:', reasonText);
                
                document.getElementById('status').textContent = `æ–­å¼€è¿æ¥ (${event.code})`;
                document.getElementById('status').className = 'disconnected';
                document.getElementById('loading').style.display = 'block';
                
                // 5ç§’åé‡è¿
                console.log('â° Will retry connection in 5 seconds...');
                setTimeout(connectWebSocket, 5000);
            };
        }
        
        function updatePointCloud(data) {
            let totalPoints = 0;
            
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯
            console.log('UpdatePointCloud called with data:', {
                hasPointcloud: !!data.pointcloud,
                hasPoints: !!(data.pointcloud && data.pointcloud.points),
                pointsLength: data.pointcloud && data.pointcloud.points ? data.pointcloud.points.length : 0,
                firstPoint: data.pointcloud && data.pointcloud.points && data.pointcloud.points.length > 0 ? data.pointcloud.points[0] : null
            });
            
            // æ›´æ–°ç‚¹äº‘
            if (data.pointcloud && data.pointcloud.points && data.pointcloud.points.length > 0) {
                const points = data.pointcloud.points;
                const positions = new Float32Array(points.length * 3);
                const colors = new Float32Array(points.length * 3);
                
                console.log(`Processing ${points.length} points for display`);
                
                for (let i = 0; i < points.length; i++) {
                    const point = points[i];
                    positions[i * 3] = point[0];
                    positions[i * 3 + 1] = point[1];
                    positions[i * 3 + 2] = point[2];
                    
                    const color = getPointColor(point);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                
                pointCloud.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                pointCloud.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                pointCloud.geometry.attributes.position.needsUpdate = true;
                pointCloud.geometry.attributes.color.needsUpdate = true;
                
                // ç¡®ä¿ç‚¹äº‘åœ¨åœºæ™¯ä¸­
                if (!scene.children.includes(pointCloud)) {
                    scene.add(pointCloud);
                    console.log('Point cloud added to scene');
                }
                
                // è°ƒæ•´ç›¸æœºä½ç½®æ¥æŸ¥çœ‹ç‚¹äº‘
                if (points.length > 0) {
                    let minX = points[0][0], maxX = points[0][0];
                    let minY = points[0][1], maxY = points[0][1];
                    let minZ = points[0][2], maxZ = points[0][2];
                    
                    for (let point of points) {
                        minX = Math.min(minX, point[0]);
                        maxX = Math.max(maxX, point[0]);
                        minY = Math.min(minY, point[1]);
                        maxY = Math.max(maxY, point[1]);
                        minZ = Math.min(minZ, point[2]);
                        maxZ = Math.max(maxZ, point[2]);
                    }
                    
                    const centerX = (minX + maxX) / 2;
                    const centerY = (minY + maxY) / 2;
                    const centerZ = (minZ + maxZ) / 2;
                    const range = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
                    
                    console.log(`Point cloud bounds: X[${minX.toFixed(2)}, ${maxX.toFixed(2)}], Y[${minY.toFixed(2)}, ${maxY.toFixed(2)}], Z[${minZ.toFixed(2)}, ${maxZ.toFixed(2)}]`);
                    console.log(`Center: (${centerX.toFixed(2)}, ${centerY.toFixed(2)}, ${centerZ.toFixed(2)}), Range: ${range.toFixed(2)}`);
                    
                    // å¦‚æœç‚¹äº‘èŒƒå›´å¾ˆå°ï¼Œè°ƒæ•´ç›¸æœº
                    if (range < 10) {
                        camera.position.set(centerX + range * 2, centerY + range * 2, centerZ + range * 2);
                        camera.lookAt(centerX, centerY, centerZ);
                        console.log('Camera position adjusted for small point cloud');
                    }
                }
                
                totalPoints = points.length;
            } else {
                console.log('No point cloud data received or points array is empty');
            }
            
            // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
            document.getElementById('pointCount').textContent = totalPoints;
            
            if (data.odom) {
                const pos = data.odom.position;
                document.getElementById('position').textContent = 
                    `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;
            }
            
            frameCount++;
        }
        
        function getPointColor(point) {
            const [x, y, z] = point;
            
            if (colorMode === 0) {
                // é«˜åº¦ç€è‰²
                const height = z;
                const normalized = Math.max(0, Math.min(1, (height + 5) / 10)); // é«˜åº¦èŒƒå›´ -5 åˆ° 5
                return {
                    r: Math.max(0, Math.min(1, normalized)),
                    g: Math.max(0, Math.min(1, (1 - Math.abs(normalized - 0.5) * 2))),
                    b: Math.max(0, Math.min(1, (1 - normalized)))
                };
            } else if (colorMode === 1) {
                // è·ç¦»ç€è‰²
                const dist = Math.sqrt(x * x + y * y + z * z);
                const normalized = Math.min(1, dist / 50);
                return {
                    r: normalized,
                    g: (1 - normalized),
                    b: 0.5
                };
            } else {
                // å•è‰²
                return { r: 0, g: 1.0, b: 0 };
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            renderer.render(scene, camera);
            
            // æ›´æ–°FPS
            const currentTime = Date.now();
            if (currentTime - lastTime > 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        function resetView() {
            camera.position.set(0, 10, 0);
            camera.up.set(0, 0, 1);
            camera.lookAt(0, 0, 0);
            controls.target.set(0, 0, 0);
            controls.update();
        }
        
        function toggleColorMode() {
            colorMode = (colorMode + 1) % 3;
            const modes = ['é«˜åº¦ç€è‰²', 'è·ç¦»ç€è‰²', 'å•è‰²'];
            console.log('Color mode:', modes[colorMode]);
        }
        
        function clearMap() {
            // æ¸…é™¤ç‚¹äº‘
            if (pointCloud.geometry) {
                pointCloud.geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
                pointCloud.geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(0), 3));
            }
            console.log('Point cloud cleared');
        }
        
        // åˆå§‹åŒ–
        init();
        
        // æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸä¾›è°ƒè¯•
        window.THREE = THREE;
        window.scene = scene;
        window.camera = camera;
    </script>
</body>
</html>
